\section{Комбинаторные игры}

\subsection{Определения}

\begin{defn}{}{}
    \( G = (V, E) \) --- ориентированный граф (считаем его конечным и ациклическим, для удобства)

    MIN, MAX --- игроки

    \( V \) --- ``позиции'' игры, в каждой позиции определено, кто ходит: MIN или MAX

    \( E \) --- ходы в игре

    \( s \in V \) --- стартовая вершина

    \( T \subseteq V \) --- терминальный позиции (игра в них кончается).

    Понятно, что \( T = \{ v \in V \: | \: \deg_+ (v) = 0 \} \).

    \( f : T \to \RR \) --- функция выигрыша для MAX: если игра заканчивается в \( t \in T \),
    то он выигрывает \( f(t) \), а MIN получает \( -f(t) \).
\end{defn}

\begin{defn}{}{}
    Партия --- путь в графе игры \( G \), стартующий в \( s \) и завершающийся в \( t \in T \).

    Результат партии --- \( f(t) \)
\end{defn}

\begin{defn}{}{}
    Стратегия --- это функция \( g: V \setminus T \to V \)
\end{defn}

\begin{defn}{}{}
    MAX может гарантировать себе выигрыш \( \geq c \),
    если \( \exists g_{MAX} \forall g_{MIN} \) результат партии \( \geq c \).
\end{defn}

\begin{defn}{}{}
    Говорят, что цена игры \( = c \), если MAX может гарантировать себе выигрыш \( \geq c \),
    а MIN может гарантировать себе выигрыш \( \leq c \).
\end{defn}

\begin{thrm}{}{}
    Для любой комбинаторной игры существует цена \( c \), причем \( c \) единственная.
\end{thrm}

Сначала покажем единственность.

Пусть у игры есть две цены \( c_1 > c_2 \).

Тогда \( \exists g_{MAX} \) с результатом \( \geq c_1 \) и \( \exists g_{MIN} \) с результатом \( \leq c_2 \).

Если сыграть \( g_{MAX} \) против \( g_{MIN} \), то результат будет \( \geq c_1 > c_2 \), что противоречит тому, что \( g_{MIN} \) гарантирует результат \( \leq c_2 \).

Теперь докажем существование.

Возьмем топологическую сортировку вершин графа игры \( v_1, v_2, \dots, v_n \),
причем \( v_1 = s \), а все вершины из \( T \) идут в конце.

Будем доказывать индукцией по суффиксу вершин, что цена игры определена и реализуется на согласованных стратегиях:

\begin{itemize}
    \item
        База:

        Для всех вершин из \( T \) цена игры --- это \( f(t) \).
    \item
        Переход:

        Пусть \( v_i \) --- вершина, в которой ходит MAX.

        Тогда \( c_i = \max\limits_{(v_i, v_j) \in E} c_j \),
        продолжаем стратегию через максимум.

        Пусть \( v_i \) --- вершина, в которой ходит MIN.

        Тогда \( c_i = \min\limits_{(v_i, v_j) \in E} c_j \),
        продолжаем стратегию через минимум.
\end{itemize}

\subsection{Беспристрастная игра Ним}

\begin{defn}{}{}
    Беспристрастная игра --- игроки ходят по очереди, проигрывает тот, кто не может сделать ход.

    \( c = \pm 1 \)
\end{defn}

\begin{defn}{}{}
    Ним --- это беспристрастная игра, в которой есть \( k \) кучек, в каждой кучке \( a_i \) камней.

    Во время хода может взять \( > 0 \) камней из одной кучки.
\end{defn}

\begin{thrm}{}{}
    \( c = -1 \) тогда и только тогда, когда \( a_1 \oplus a_2 \oplus \dots \oplus a_k = 0 \).
\end{thrm}

\begin{itemize}
    \item
        \( a_1 \oplus a_2 \oplus \dots \oplus a_k = 0 \)

        Очевидно, что после любого хода XOR перестанет быть нулем.
    \item
        \( a_1 \oplus a_2 \oplus \dots \oplus a_k \neq 0 \).

        Пусть \( a_i \) --- кучка, в которой стоит старшая единица в XOR.
        Тогда можно сделать ход в \( a_i \), чтобы XOR стал нулем:
        уберем эту старшую единицу, а все более младшие биты в \( a_i \) сделаем такими же, как в XOR
        (можем так сделать, потому что после удаления ``старшей единицы'' на более младших позициях
        можно получить любую комбинацию битов)
\end{itemize}

Поскольку \( k \) пустых кучек --- терминальная позиция, то \( c = -1 \) тогда и только тогда, когда \( a_1 \oplus a_2 \oplus \dots \oplus a_k = 0 \).

\subsection{Решающие деревья}

\subsubsection{Примеры и определения}

\begin{example}{Задача об угадывании числа}{}
    \begin{itemize}
        \item
            Алиса загадывает число от \( 1 \) до \( N \)
        \item
            Боб хочет угадать число, задавая вопросы вида ``верно ли, что \( x \in S \)?''
    \end{itemize}

    По индукции показывается, что нам хватит \( k = \lceil \log_2 N \rceil \) вопросов.
\end{example}

\begin{defn}{}{}
    Алгоритм (протокол) --- дерево.

    \begin{itemize}{}{}
        \item
            Узлы --- \( S_i \subseteq A \) (соответствующие вопросы)
        \item
            Листья --- ответы (\( f(x) \))
        \item
            Вопросы вила ``\( x \in S \)?'' (\( S \subseteq A \))
        \item
            Цель: найти \( f(x) \)
        \item
            Сложность протокола --- глубина дерева
    \end{itemize}

    Есть два вида протоколов:
    \begin{itemize}
        \item
            Адаптивный --- вопросы задаются последовательно.
        \item
            Неадаптивный --- все вопросы задаются сразу.
    \end{itemize}
\end{defn}

\begin{thrm}{}{}
    Адаптивная сложность задачи об угадывании числа \( x \in [1, N] \) равна \( \lceil \log_2 N \rceil \).
\end{thrm}

Пусть есть протокол, решающий задачу, глубины \( k \).
Значит в нем \( r \leq 2^k \) листьев.
\( N \leq r \leq 2^k \), а значит \( k \geq \lceil \log_2 N \rceil   \).
А само число, например, можно найти бинарным поиском.

\begin{remark}{}{}
    На самом деле, неадаптивная сложность тоже равна \( \lceil \log_2 N \rceil \).

    Если считать, что \( 0 < x < N \leq 2^k \) (сдвинем отрезок \( [1, N] \) на \( 1 \)),
    то можно за \( k \) вопросов узнать каждый бит числа.
\end{remark}

\begin{thrm}{}{}
    Для каждого адаптивного протокола сложности \( t \)
    существует неадаптивный протокол сложности \( t \),
    решающий ту же задачу.
\end{thrm}

\begin{enumerate}
    \item
        \( x \in S_1 \)
    \item
        Если \( x \in S_1 \), то верно ли, что \( x \in S_3 \)?

        Иначе верно ли, что \( x \in S_2 \)?

        На самом деле это вопрос вида \( x \in (S_1 \cap S_3) \cup (\ol{S_1} \cap S_2) \)
    \item
        Продолжать в том же духе
\end{enumerate}

\subsubsection{Задача о сортировке}

Есть неизвестная нам перестановка \( \sigma \in S_n \).

Можем спрашивать вопросы вида ``\( \sigma_i < \sigma_j \)?''

Нужно найти \( \sigma \).

\begin{thrm}{}{}
    \[
        \lceil \log_2 n! \rceil \leq SORT(n) \leq \sum\limits_{k = 1}^{n} \lceil \log_2 k \rceil
    \]
\end{thrm}

\begin{exercise}{}{}
    Выведите из этого, что \( SORT(n) = \Theta (n \log n) \)
\end{exercise}

Нижняя оценка доказывается так, как и в задаче об угадывании числа, в нашем случае \( |S_n| = n! \)

Вторую оценку докажем по индукции:

Пусть \( SORT(n) \leq \sum\limits_{k = 1}^{n} \lceil \log_2 k \rceil \).

Сделаем переход \( n \to n + 1 \)

Временно отложим первый элемент и найдем относительный порядок оставшихся \( n \) за \( SORT(n) \).
Теперь нужно понять, в каком из \( n + 1 \) промежутков находится первый элемент.
Сделаем это с помощью бинарного поиска за \( \lceil \log_2 (n + 1) \rceil \).

Получили, что:
\[
    SORT(n + 1)
    \leq
    SORT(n) + \lceil \log_2 (n + 1) \rceil
    \leq
    \sum\limits_{k = 1}^{n} \lceil \log_2 k \rceil + \lceil \log_2 (n + 1) \rceil
    \leq
    \sum\limits_{k = 1}^{n + 1} \lceil \log_2 k \rceil
\]

\subsubsection{Задача о поиске максимума}

Есть неизвестная нам перестановка \( \sigma \in S_n \).

Можем спрашивать вопросы вида ``\( \sigma_i < \sigma_j \)?''

Нужно найти позицию максимального элемента в \( \sigma \).

\begin{thrm}{}{}
    \[
        MAX(n) = n - 1
    \]
\end{thrm}

Сначала приведем алгоритм: пройдемся слева направо по перестановке,
каждый раз сравнивая текущего кандидата на максимума с рассматриваемым элементом.

Осталось показать, что за меньшее число вопросов не получится найти ответ.
Пусть существует протокол сложности \( k < n - 1 \), решающий данную задачу.
Посмтроим граф: \( V = \{ 1, \ldots, n \} \).
Ребрами же соединим те элементы, которые мы сравнили в процессе алгоритма между собой.
Поскольку \( k < n - 1 \), в нашем графе точно меньше \( n - 1 \) ребра,
а значит он несвязен.
Пусть нам выдало какой-то ответ.
Давайте в какой-нибудь другой компоненте прибавим \( n \) (и подкорректируем порядок в перестановке),
тогда ответы на вопросы не изменятся, но наш ответ будет неправильным.

\begin{thrm}{}{}
    Неадаптивная сложность задачи о поиске максимума из \( n \) объектов равна \( \binom{n}{2} \)
\end{thrm}

Найти максимум за такое число вопросов несложно --- нужно просто спросить про все пары.

Теперь предположим, что мы задали \( k < \binom{n}{2} \) вопросов.
В таком случае мы не спросили про какую-то пару объектов \( a, b \).
Давайте сделаем их двумя максимальными.
В таком случае, если поменять их местами, то ответы на вопросы не изменятся, но при этом максимальный элемент поменяется.
А значит \( k \) вопросов не хватит.

\subsubsection{Сложность булевой функции}

\begin{defn}{}{}
    Сложность булевой функции \( f : \{ 0, 1 \}^b \to \{ 0, 1 \} \) в модели решающих деревьев (\( D(f) \))
    --- это сложность адаптивного протокола для вычисления \( f \) (мы знаем функцию, но не знаем набор входных параметров)
    при вопросах вида:
    \[
        S_i = \{ (a_1, \ldots, a_n) \in \{ 0, 1 \}^n \: | \: a_i = 1 \}
    \]
\end{defn}

\begin{exercise}{}{}
    Существует функция, у которой сложность меньше числа существенных переменных в ней.
\end{exercise}

\begin{defn}{}{}
    \( CONN : \{ 0, 1 \}^{\binom{n}{2}} \to \{ 0, 1 \} \)

    \begin{itemize}
        \item
            Переменные функции --- наличие соответствующих ребер в графе на \( n \) вершинах.
        \item
            Результат --- связен ли граф на данных ребрах.
    \end{itemize}
\end{defn}

\begin{thrm}{}{}
    \[
        D(CONN(n)) = \binom{n}{2}
    \]
\end{thrm}

Очевидно, что оценка реализуется.

Пусть существует алгоритм, который раскрывает \( k < \binom{n}{2} \) ребер.
Снова будем играть за противника:
\begin{itemize}{}{}
    \item
        Ребро внутри компоненты.

        Ответим как хотим.
    \item
        Ребро между разными компонентами.

        Если про все остальные ребра между этими компонентами уже спросили,
        то ответим ``Да'', иначе --- ``Нет''.
\end{itemize}

Если раскрыты не все ребра, то ``неспрошенные'' ребра связывают разные компоненты связности.
Это можно доказать индукцией по числу спрошенных ребер.
